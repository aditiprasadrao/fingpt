# demo_db_streamlit.py
# DB-backed simulated Crypto Sentiment Dashboard (uses your src.storage.db schema)

import streamlit as st
import pandas as pd
import numpy as np
import time
from datetime import datetime, timezone
import threading
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from sqlalchemy import insert

# project DB module
from src.storage import db as dbmod

st.set_page_config(layout="wide", page_title="Demo DB Crypto Sentiment")

ANALYZER = SentimentIntensityAnalyzer()

SYMBOL = st.sidebar.selectbox("Symbol", ["BTC-USD", "ETH-USD"])
START_BUTTON = st.sidebar.button("Start Simulation")
STOP_BUTTON = st.sidebar.button("Stop Simulation")

sim_rate = st.sidebar.slider("Tick interval (sec)", 0.5, 5.0, 1.0, 0.5)
post_rate = st.sidebar.slider("Post interval (sec)", 5, 60, 15, 5)

state = {"running": False, "price": {"BTC-USD": 50000.0, "ETH-USD": 3500.0}}

SAMPLE_POSTS = [
    "Bitcoin to the moon! Very bullish today.",
    "This looks like a huge dump, sell now!",
    "Great long-term fundamentals, buy the dip.",
    "Scared about the market, terrible news.",
    "Partnerships announced, promising future.",
    "Huge whale sell wall, panic.",
    "Amazing upgrade, ETH looking strong.",
    "Market manipulation? Not sure, cautious."
]

def score_text(text):
    return float(ANALYZER.polarity_scores(text)["compound"])

def simulate_tick_loop(interval):
    engine = dbmod.engine
    while state["running"]:
        ts = datetime.now(timezone.utc)
        for sym in ["BTC-USD", "ETH-USD"]:
            base = state["price"][sym]
            drift = np.random.normal(loc=0.0, scale=0.2)
            new_price = max(0.1, base * (1 + drift/100.0))
            vol = float(max(0.0, np.random.exponential(scale=0.5)))
            state["price"][sym] = new_price
            # insert into tickers: columns -> (symbol, price, volume, ts)
            stmt = insert(dbmod.tickers).values(symbol=sym, price=float(new_price), volume=vol, ts=ts)
            with engine.begin() as c:
                c.execute(stmt)
        time.sleep(interval)

def simulate_posts_loop(interval):
    engine = dbmod.engine
    while state["running"]:
        ts = datetime.now(timezone.utc)
        txt = np.random.choice(SAMPLE_POSTS)
        sent = score_text(txt)
        # reddit_posts columns -> (id VARCHAR maybe autogenerated, subreddit, text, sentiment, created_utc DATETIME)
        stmt = insert(dbmod.reddit_posts).values(subreddit="CryptoCurrency", text=txt, sentiment=sent, created_utc=ts)
        with engine.begin() as c:
            c.execute(stmt)
        time.sleep(interval)

def start_simulation(tick_interval, post_interval):
    if state["running"]:
        return
    state["running"] = True
    threading.Thread(target=simulate_tick_loop, args=(tick_interval,), daemon=True).start()
    threading.Thread(target=simulate_posts_loop, args=(post_interval,), daemon=True).start()

def stop_simulation():
    state["running"] = False

if START_BUTTON:
    start_simulation(sim_rate, post_rate)
if STOP_BUTTON:
    stop_simulation()

st.title("Demo (DB-backed) Crypto Sentiment Dashboard")

# Read aggregates from DB using your helper
try:
    rows = dbmod.get_recent_aggregates(SYMBOL, limit=120)
    df = pd.DataFrame(rows)
    if not df.empty:
        # Expect columns: ts, open_price, close_price, avg_sentiment, post_count, ...
        df['ts'] = pd.to_datetime(df['ts'])
        # plotting uses close_price & avg_sentiment
        import plotly.graph_objects as go
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=df['ts'], y=df['close_price'], name='Close Price'))
        fig.add_trace(go.Scatter(x=df['ts'], y=df['avg_sentiment'], name='Avg Sentiment', yaxis='y2'))
        fig.update_layout(
            yaxis=dict(title='Price'),
            yaxis2=dict(title='Sentiment', overlaying='y', side='right', range=[-1,1])
        )
        st.plotly_chart(fig, width="stretch")


        st.subheader("Latest aggregates (tail)")
        st.dataframe(df.tail(20).reset_index(drop=True))
    else:
        st.info("No aggregates yet. Start simulation and/or run the aggregator.")
except Exception as e:
    st.error(f"DB read error: {e}")
    st.exception(e)
